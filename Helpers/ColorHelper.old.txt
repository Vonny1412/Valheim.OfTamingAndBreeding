using System;
using System.Collections.Generic;
using UnityEngine;

namespace OfTamingAndBreeding.Helpers
{

    public static class ColorHelper
    {
        // --------- CONFIG ---------
        // Factor quantization (10000f = 4 decimal places)
        private const float Quant = 10000f;

        // --------- CACHES ---------
        // schemeKey -> (qFactor -> "#RRGGBB")
        private static readonly Dictionary<int, Dictionary<int, string>> schemeCache = new Dictionary<int, Dictionary<int, string>>();
        // "#RRGGBB" hash -> packed RGB (0xRRGGBB)
        private static readonly Dictionary<int, int> parsedHexCache = new Dictionary<int, int>();

        private static readonly object cacheLock = new object();

        /// <summary>
        /// Optional: Clear cache completely (e.g., if user changes config colors).
        /// </summary>
        public static void ClearCaches()
        {
            lock (cacheLock)
            {
                schemeCache.Clear();
                parsedHexCache.Clear();
            }
        }

        public static string GetColorBetween(
            string colorBad,
            string colorNormal,
            string colorGood,
            float factor,
            float min,
            float max,
            bool useCache = true)
        {

            // fast outs
            if (Mathf.Approximately(factor, 1f)) return colorNormal;
            if (factor >= max) return colorGood;
            if (factor <= min) return colorBad;

            // decide branch
            bool goodSide = factor > 1f;

            // if any needed color is not hex, bail out to target color (no lerp)
            if (goodSide)
            {
                if (!IsHexColor(colorNormal) || !IsHexColor(colorGood))
                    return colorGood;
            }
            else
            {
                if (!IsHexColor(colorNormal) || !IsHexColor(colorBad))
                    return colorBad;
            }

            // normalize factor to t [0..1]
            float t;
            if (goodSide)
            {
                t = (factor - 1f) / (max - 1f);
            }
            else
            {
                t = (1f - factor) / (1f - min);
            }
            t = Mathf.Clamp01(t);

            // quantize (important for cache stability)
            int qFactor = Mathf.RoundToInt(t * Quant);      // 0..10000
            int qMin = Mathf.RoundToInt((1/min) * Quant);
            int qMax = Mathf.RoundToInt(max * Quant);

            // --------- CACHE LOOKUP ---------
            if (useCache)
            {
                int schemeKey = MakeSchemeKey(colorBad, colorNormal, colorGood, qMin, qMax, goodSide);

                lock (cacheLock)
                {
                    if (schemeCache.TryGetValue(schemeKey, out var inner) &&
                        inner.TryGetValue(qFactor, out var cached))
                    {
                        return cached;
                    }
                }

                // miss -> compute, then store
                string computed = ComputeLerpedHex(colorBad, colorNormal, colorGood, qFactor, goodSide);

                lock (cacheLock)
                {
                    if (!schemeCache.TryGetValue(schemeKey, out var inner))
                    {
                        inner = new Dictionary<int, string>(64);
                        schemeCache[schemeKey] = inner;
                    }
                    inner[qFactor] = computed;
                }

                return computed;
            }

            // no-cache path
            return ComputeLerpedHex(colorBad, colorNormal, colorGood, qFactor, goodSide);
        }

        // ---------------------------------------------
        // Core compute
        // ---------------------------------------------
        private static string ComputeLerpedHex(
            string colorBad,
            string colorNormal,
            string colorGood,
            int qFactor, // 0..10000
            bool goodSide)
        {
            float t = qFactor / Quant;

            int packedA = GetPackedRgbCached(colorNormal);

            int packedB = goodSide
                ? GetPackedRgbCached(colorGood)
                : GetPackedRgbCached(colorBad);

            // unpack
            int ar = (packedA >> 16) & 0xFF;
            int ag = (packedA >> 8) & 0xFF;
            int ab = packedA & 0xFF;

            int br = (packedB >> 16) & 0xFF;
            int bg = (packedB >> 8) & 0xFF;
            int bb = packedB & 0xFF;

            // lerp bytes
            int rr = Mathf.Clamp(Mathf.RoundToInt(ar + (br - ar) * t), 0, 255);
            int rg = Mathf.Clamp(Mathf.RoundToInt(ag + (bg - ag) * t), 0, 255);
            int rb = Mathf.Clamp(Mathf.RoundToInt(ab + (bb - ab) * t), 0, 255);

            return $"#{rr:X2}{rg:X2}{rb:X2}";
        }

        // ---------------------------------------------
        // Scheme key
        // ---------------------------------------------
        private static int MakeSchemeKey(string bad, string normal, string good, int qMin, int qMax, bool goodSide)
        {
            unchecked
            {
                int h = 17;
                h = h * 31 + (bad?.GetHashCode() ?? 0);
                h = h * 31 + (normal?.GetHashCode() ?? 0);
                h = h * 31 + (good?.GetHashCode() ?? 0);
                h = h * 31 + qMin;
                h = h * 31 + qMax;
                h = h * 31 + (goodSide ? 1 : 0);
                return h;
            }
        }

        // ---------------------------------------------
        // Hex parsing + cache (packed int 0xRRGGBB)
        // ---------------------------------------------
        private static int GetPackedRgbCached(string hex)
        {
            int key = hex.GetHashCode();

            lock (cacheLock)
            {
                if (parsedHexCache.TryGetValue(key, out int packed))
                    return packed;
            }

            int parsed = ParseHexPacked(hex);

            lock (cacheLock)
            {
                parsedHexCache[key] = parsed;
            }

            return parsed;
        }

        private static int ParseHexPacked(string hex)
        {
            // expects "#RRGGBB" (validated before)
            int r = (HexVal(hex[1]) << 4) | HexVal(hex[2]);
            int g = (HexVal(hex[3]) << 4) | HexVal(hex[4]);
            int b = (HexVal(hex[5]) << 4) | HexVal(hex[6]);
            return (r << 16) | (g << 8) | b;
        }

        private static int HexVal(char c)
        {
            if (c >= '0' && c <= '9') return c - '0';
            if (c >= 'a' && c <= 'f') return 10 + (c - 'a');
            return 10 + (c - 'A'); // assume A..F
        }

        private static bool IsHexColor(string s)
        {
            if (string.IsNullOrEmpty(s) || s.Length != 7 || s[0] != '#') return false;
            for (int i = 1; i < 7; i++)
            {
                char c = s[i];
                bool ok =
                    (c >= '0' && c <= '9') ||
                    (c >= 'a' && c <= 'f') ||
                    (c >= 'A' && c <= 'F');
                if (!ok) return false;
            }
            return true;
        }
    }

}
